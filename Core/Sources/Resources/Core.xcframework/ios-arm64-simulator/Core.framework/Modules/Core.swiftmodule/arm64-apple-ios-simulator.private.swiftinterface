// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.8.1 (swiftlang-5.8.0.124.5 clang-1403.0.22.11.100)
// swift-module-flags: -target arm64-apple-ios16.1-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -Onone -module-name Core
// swift-module-flags-ignorable: -enable-bare-slash-regex
import Alamofire
import Combine
@_exported import Core
import Foundation
import KeychainAccess
import Network
import Swift
import _Concurrency
import _StringProcessing
infix operator + : DefaultPrecedence
public typealias Parameters = Alamofire.Parameters
public enum ParameterEncoder {
  case json
  case url
  public static func == (a: Core.ParameterEncoder, b: Core.ParameterEncoder) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum ParameterEncoding {
  case json
  case url
  case body
  case queryString
  public static func == (a: Core.ParameterEncoding, b: Core.ParameterEncoding) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct HTTPMethod : Swift.Equatable, Swift.Hashable, Swift.RawRepresentable {
  public static let delete: Core.HTTPMethod
  public static let get: Core.HTTPMethod
  public static let patch: Core.HTTPMethod
  public static let post: Core.HTTPMethod
  public static let put: Core.HTTPMethod
  public let rawValue: Swift.String
  public init(rawValue: Swift.String)
  public typealias RawValue = Swift.String
}
public class HTTPApiClientConfiguration {
  public var allowsCellularAccess: Swift.Bool
  public var httpAdditionalHeaders: Core.HTTPHeaders
  public var protocolClasses: [Swift.AnyClass]
  public var requestCachePolicy: Foundation.NSURLRequest.CachePolicy
  public var requestRetryCount: Swift.Int
  public var timeoutIntervalForRequest: Swift.Double
  public var timeoutIntervalForResource: Swift.Double
  public init()
  @objc deinit
}
open class HTTPApiClient {
  final public let configuration: Core.HTTPApiClientConfiguration
  final public let interceptor: (any Core.RequestInterceptor)?
  final public let monitor: Core.CompositeRequestMonitor
  final public let status: Combine.CurrentValueSubject<Network.NWPath.Status, Swift.Never>
  final public let url: Swift.String
  public init(url: Swift.String, configuration: Core.HTTPApiClientConfiguration? = nil, interceptor: (any Core.RequestInterceptor)? = nil, monitors: [any Core.RequestMonitor] = [])
  open func removeHeader(forKey key: Swift.String)
  open func setHeader(_ header: Core.HTTPHeader)
  open func request(_ path: Swift.String, method: Core.HTTPMethod, parameters: Core.Parameters? = nil, encoding: Core.ParameterEncoding? = nil, headers: Core.HTTPHeaders = [:], interceptor: (any Core.RequestInterceptor)? = nil) throws -> Core.DataRequest
  open func request<E>(_ path: Swift.String, method: Core.HTTPMethod, parameters: E? = nil, encoder: Core.ParameterEncoder? = nil, headers: Core.HTTPHeaders = [:], interceptor: (any Core.RequestInterceptor)? = nil) throws -> Core.DataRequest where E : Swift.Encodable
  @objc deinit
}
public enum RetryPolicy {
  case retry
  case doNotRetry
  public static func == (a: Core.RetryPolicy, b: Core.RetryPolicy) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol RequestInterceptor {
  #if compiler(>=5.3) && $AsyncAwait
  func intercept(_ request: Foundation.URLRequest, client: Core.HTTPApiClient) async throws -> Foundation.URLRequest
  #endif
}
public protocol RequestRetrier {
  #if compiler(>=5.3) && $AsyncAwait
  func retry(_ request: Core.Request, for client: Core.HTTPApiClient, dueTo error: any Swift.Error) async -> Core.RetryPolicy
  #endif
}
public struct Interceptor : Core.RequestInterceptor, Core.RequestRetrier {
  public let interceptors: [any Core.RequestInterceptor]
  public let retriers: [any Core.RequestRetrier]
  public init(interceptors: [any Core.RequestInterceptor], retriers: [any Core.RequestRetrier])
  #if compiler(>=5.3) && $AsyncAwait
  public func intercept(_ request: Foundation.URLRequest, client: Core.HTTPApiClient) async throws -> Foundation.URLRequest
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  public func retry(_ request: Core.Request, for client: Core.HTTPApiClient, dueTo error: any Swift.Error) async -> Core.RetryPolicy
  #endif
}
#if compiler(>=5.3) && $Actors
public actor BearerTokenRequestRetrier : Core.RequestRetrier {
  public init(tokenProvider: any Core.TokenProvider)
  #if compiler(>=5.3) && $AsyncAwait
  public func retry(_ request: Core.Request, for client: Core.HTTPApiClient, dueTo error: any Swift.Error) async -> Core.RetryPolicy
  #endif
  @objc deinit
  @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
  @_semantics("defaultActor") nonisolated final public var unownedExecutor: _Concurrency.UnownedSerialExecutor {
    get
  }
}
#endif
public typealias Redirector = (Foundation.URLSessionTask, Foundation.URLRequest, Foundation.HTTPURLResponse) -> Foundation.URLRequest?
@_hasMissingDesignatedInitializers open class Request {
  public typealias ValidationCallback = (Foundation.URLRequest?, Foundation.HTTPURLResponse, Foundation.Data?) -> Swift.Result<Swift.Void, any Swift.Error>
  final public let id: Foundation.UUID
  final public let interceptor: (any Core.RequestInterceptor)?
  public var metrics: Foundation.URLSessionTaskMetrics? {
    get
  }
  final public let monitor: (any Core.RequestMonitor)?
  public var request: Foundation.URLRequest? {
    get
  }
  public var response: Foundation.HTTPURLResponse? {
    get
  }
  public var retryCount: Swift.Int {
    get
  }
  public var state: Core.Request.State {
    get
  }
  public var task: Foundation.URLSessionTask? {
    get
  }
  public var tasks: [Foundation.URLSessionTask] {
    get
  }
  public enum State {
    case cancelled
    case finished
    case initialized
    case resumed
    case suspended
    public static func == (a: Core.Request.State, b: Core.Request.State) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @discardableResult
  public func cancel() -> Self
  public func cURLDescription() -> Swift.String
  @discardableResult
  public func redirect(using redirector: @escaping Core.Redirector) -> Self
  @discardableResult
  public func resume() -> Self
  @discardableResult
  public func suspend() -> Self
  @objc deinit
}
@_hasMissingDesignatedInitializers public class DataRequest : Core.Request {
  @discardableResult
  public func serializing<Value>(_ type: Value.Type, serializer: @escaping ((Foundation.URLRequest?, Foundation.HTTPURLResponse?, Foundation.Data?, (any Swift.Error)?) throws -> Value)) -> Core.AsyncDataTask<Value> where Value : Swift.Decodable
  @discardableResult
  public func serializing<Value>(_ type: Value.Type, decoder: Foundation.JSONDecoder = JSONDecoder(), emptyResponseCodes: Swift.Set<Swift.Int>? = nil) -> Core.AsyncDataTask<Value> where Value : Swift.Decodable
  @discardableResult
  public func serializingData(emptyResponseCodes: Swift.Set<Swift.Int>? = nil) -> Core.AsyncDataTask<Foundation.Data>
  @discardableResult
  public func validate() -> Self
  @discardableResult
  public func validate(_ callback: @escaping Core.DataRequest.ValidationCallback) -> Self
  @discardableResult
  public func validate<S>(acceptableStatusCodes: S) -> Self where S : Swift.Sequence, S.Element == Swift.Int
  @objc deinit
}
public struct AsyncDataTask<Value> {
  #if compiler(>=5.3) && $EffectfulProp
  public var response: Core.Response<Value> {
    get async
  }
  #endif
  #if compiler(>=5.3) && $EffectfulProp
  public var result: Swift.Result<Value, Core.NetworkError> {
    get async
  }
  #endif
  #if compiler(>=5.3) && $EffectfulProp
  public var value: Value {
    get async throws
  }
  #endif
  public func cancel()
  public func resume()
  public func suspend()
}
public struct AuthToken : Swift.Codable, Swift.Equatable {
  public let id: Swift.String
  public let accessToken: Swift.String
  public let refreshToken: Swift.String
  public init(id: Swift.String, accessToken: Swift.String, refreshToken: Swift.String)
  public static func == (a: Core.AuthToken, b: Core.AuthToken) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct Response<Success> {
  public let data: Foundation.Data?
  public var error: Core.NetworkError? {
    get
  }
  public let request: Foundation.URLRequest?
  public let response: Foundation.HTTPURLResponse?
  public let result: Swift.Result<Success, Core.NetworkError>
  public var value: Success? {
    get
  }
  public func map<NewSuccess>(_ transform: (Success) -> NewSuccess) -> Core.Response<NewSuccess>
}
extension Core.Response : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
public struct UserDefaultsStorage : Core.Storage {
  public init(userDefaults: Foundation.UserDefaults = .standard)
  public func clear() throws
  public func delete(key: Swift.String) throws
  public func readValue<T>(_ type: T.Type, forKey key: Swift.String) throws -> T? where T : Swift.Decodable
  public func write<T>(_ value: T, forKey key: Swift.String) throws where T : Swift.Encodable
}
extension Foundation.URLRequest {
  public var allHTTPHeaders: Core.HTTPHeaders {
    get
    set
  }
}
extension Foundation.URLSessionConfiguration {
  public var allHTTPHeaders: Core.HTTPHeaders {
    get
    set
  }
}
public struct HTTPHeader : Swift.Hashable {
  public let name: Swift.String
  public let value: Swift.String
  public static var defaultAcceptLanguage: Core.HTTPHeader {
    get
  }
  public static func acceptLanguage(_ value: Swift.String) -> Core.HTTPHeader
  public static func authorization(_ value: Swift.String) -> Core.HTTPHeader
  public static func bearerToken(_ value: Swift.String) -> Core.HTTPHeader
  public static func contentType(_ value: Swift.String) -> Core.HTTPHeader
  public init(name: Swift.String, value: Swift.String)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: Core.HTTPHeader, b: Core.HTTPHeader) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct HTTPHeaders {
  public var dictionary: [Swift.String : Swift.String] {
    get
  }
  public subscript(name: Swift.String) -> Swift.String? {
    get
    set
  }
  public static var `default`: Core.HTTPHeaders {
    get
  }
  public init(array: [Core.HTTPHeader] = [])
  public init(dictionary: [Swift.String : Swift.String])
  public mutating func append(_ header: Core.HTTPHeader)
  public mutating func removeHeader(forKey key: Swift.String)
  public mutating func setHeader(_ value: Swift.String, forKey key: Swift.String)
}
extension Core.HTTPHeaders : Swift.ExpressibleByArrayLiteral {
  public init(arrayLiteral elements: Core.HTTPHeader...)
  public typealias ArrayLiteralElement = Core.HTTPHeader
}
extension Core.HTTPHeaders : Swift.ExpressibleByDictionaryLiteral {
  public init(dictionaryLiteral elements: (Swift.String, Swift.String)...)
  public typealias Key = Swift.String
  public typealias Value = Swift.String
}
extension Core.HTTPHeaders : Swift.Collection {
  public var endIndex: Swift.Int {
    get
  }
  public var startIndex: Swift.Int {
    get
  }
  public subscript(position: Swift.Int) -> Core.HTTPHeader {
    get
  }
  public func index(after i: Swift.Int) -> Swift.Int
  public typealias Element = Core.HTTPHeader
  public typealias Index = Swift.Int
  public typealias Indices = Swift.DefaultIndices<Core.HTTPHeaders>
  public typealias Iterator = Swift.IndexingIterator<[Core.HTTPHeader]>
  public typealias SubSequence = Swift.Slice<Core.HTTPHeaders>
}
extension Core.HTTPHeaders : Swift.Sequence {
  public func makeIterator() -> Swift.IndexingIterator<[Core.HTTPHeader]>
}
public protocol RequestMonitor {
  var queue: Dispatch.DispatchQueue { get }
  func request(_ request: Core.DataRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, data: Foundation.Data?, result: Swift.Result<Swift.Void, any Swift.Error>)
  func request(_ request: Core.DataRequest, didParseResponse response: Core.Response<Foundation.Data?>)
  func request<Value>(_ request: Core.DataRequest, didParseResponse response: Core.Response<Value>)
  func request(_ request: Core.Request, didCollectMetrics metrics: Foundation.URLSessionTaskMetrics)
  func request(_ request: Core.Request, didCompleteTask task: Foundation.URLSessionTask, with error: Core.NetworkError?)
  func request(_ request: Core.Request, didCreateSesionTask task: Foundation.URLSessionTask)
  func request(_ request: Core.Request, didCreateURLRequest urlRequest: Foundation.URLRequest)
  func request(_ request: Core.Request, didFailToCreateURLRequest error: Core.NetworkError)
  func request(_ request: Core.Request, didFailToInterceptURLRequest request: Foundation.URLRequest, withError error: Core.NetworkError)
  func request(_ request: Core.Request, didInterceptRequest urlRequest: Foundation.URLRequest, to modifiedRequest: Foundation.URLRequest)
  func requestDidCancel(_ request: Core.Request)
  func requestDidComplete(_ request: Core.Request)
  func requestDidResume(_ request: Core.Request)
  func requestDidSuspend(_ request: Core.Request)
  func requestIsRetrying(_ request: Core.Request)
}
extension Core.RequestMonitor {
  public func request(_ request: Core.DataRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, data: Foundation.Data?, result: Swift.Result<Swift.Void, any Swift.Error>)
  public func request(_ request: Core.DataRequest, didParseResponse response: Core.Response<Foundation.Data?>)
  public func request<Value>(_ request: Core.DataRequest, didParseResponse response: Core.Response<Value>)
  public func request(_ request: Core.Request, didCollectMetrics metrics: Foundation.URLSessionTaskMetrics)
  public func request(_ request: Core.Request, didCompleteTask task: Foundation.URLSessionTask, with error: Core.NetworkError?)
  public func request(_ request: Core.Request, didCreateSesionTask task: Foundation.URLSessionTask)
  public func request(_ request: Core.Request, didCreateURLRequest urlRequest: Foundation.URLRequest)
  public func request(_ request: Core.Request, didFailToCreateURLRequest error: Core.NetworkError)
  public func request(_ request: Core.Request, didFailToInterceptURLRequest urlRequest: Foundation.URLRequest, withError error: Core.NetworkError)
  public func request(_ request: Core.Request, didInterceptRequest urlRequest: Foundation.URLRequest, to modifiedRequest: Foundation.URLRequest)
  public func requestDidCancel(_ request: Core.Request)
  public func requestDidComplete(_ request: Core.Request)
  public func requestDidResume(_ request: Core.Request)
  public func requestDidSuspend(_ request: Core.Request)
  public func requestIsRetrying(_ request: Core.Request)
}
public struct CompositeRequestMonitor : Core.RequestMonitor {
  public let queue: Dispatch.DispatchQueue
  public func request(_ request: Core.DataRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, data: Foundation.Data?, result: Swift.Result<Swift.Void, any Swift.Error>)
  public func request(_ request: Core.DataRequest, didParseResponse response: Core.Response<Foundation.Data?>)
  public func request<Value>(_ request: Core.DataRequest, didParseResponse response: Core.Response<Value>)
  public func request(_ request: Core.Request, didCollectMetrics metrics: Foundation.URLSessionTaskMetrics)
  public func request(_ request: Core.Request, didCompleteTask task: Foundation.URLSessionTask, with error: Core.NetworkError?)
  public func request(_ request: Core.Request, didCreateSesionTask task: Foundation.URLSessionTask)
  public func request(_ request: Core.Request, didCreateURLRequest urlRequest: Foundation.URLRequest)
  public func request(_ request: Core.Request, didFailToCreateURLRequest error: Core.NetworkError)
  public func request(_ request: Core.Request, didFailToInterceptURLRequest urlRequest: Foundation.URLRequest, withError error: Core.NetworkError)
  public func request(_ request: Core.Request, didInterceptRequest urlRequest: Foundation.URLRequest, to modifiedRequest: Foundation.URLRequest)
  public func requestDidCancel(_ request: Core.Request)
  public func requestDidComplete(_ request: Core.Request)
  public func requestDidResume(_ request: Core.Request)
  public func requestDidSuspend(_ request: Core.Request)
  public func requestIsRetrying(_ request: Core.Request)
}
public protocol AuthenticationClient {
  #if compiler(>=5.3) && $AsyncAwait
  func authenticate(using signature: Swift.String, payload: Swift.String) async throws
  #endif
}
extension Foundation.JSONDecoder : Core.Decoder {
}
public protocol Decoder {
  func decode<T>(_ type: T.Type, from data: Foundation.Data) throws -> T where T : Swift.Decodable
}
final public class HTTPAuthenticationClient : Core.AuthenticationClient {
  public init(apiKey: Swift.String, apiClient: Core.HTTPApiClient, tokenProvider: any Core.TokenProvider, decoder: any Core.Decoder = JSONDecoder())
  #if compiler(>=5.3) && $AsyncAwait
  final public func authenticate(using signature: Swift.String, payload: Swift.String) async throws
  #endif
  @objc deinit
}
public struct ApiClientMonitor : Core.RequestMonitor {
  public let queue: Dispatch.DispatchQueue
  public init()
  public func requestDidResume(_ request: Core.Request)
  public func request<Value>(_ request: Core.DataRequest, didParseResponse response: Core.Response<Value>)
}
#if compiler(>=5.3) && $Actors
public actor BearerTokenProvider : Core.TokenProvider {
  public init(storage: any Core.Storage = KeychainStorage(accessGroup: Bundle.main.bundleIdentifier ?? ""))
  #if compiler(>=5.3) && $AsyncAwait
  public func retrieveToken() async -> Core.AuthToken?
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  public func save(_ authToken: Core.AuthToken) async throws
  #endif
  @objc deinit
  @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
  @_semantics("defaultActor") nonisolated final public var unownedExecutor: _Concurrency.UnownedSerialExecutor {
    get
  }
}
#endif
public protocol TokenProvider {
  #if compiler(>=5.3) && $AsyncAwait
  func retrieveToken() async -> Core.AuthToken?
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  func save(_ authToken: Core.AuthToken) async throws
  #endif
}
public class InMemoryStorage : Core.Storage {
  public init()
  public func clear() throws
  public func delete(key: Swift.String) throws
  public func readValue<T>(_ type: T.Type, forKey key: Swift.String) throws -> T? where T : Swift.Decodable
  public func write<T>(_ value: T, forKey key: Swift.String) throws where T : Swift.Encodable
  @objc deinit
}
public struct NetworkError : Foundation.LocalizedError {
  public let column: Swift.Int
  public let line: Swift.Int
  public let kind: Core.NetworkError.ErrorKind
  public let underlyingError: (any Swift.Error)?
  public var errorDescription: Swift.String? {
    get
  }
  public enum ErrorKind {
    case explicitlyCancelled
    case invalidURL(url: Swift.String)
    case parameterEncodingFailed
    case requestAdaptationFailed
    case requestRetryFailed
    case responseSerializationFailed
    case responseValidationFailed
    case sessionInvalidated
    case sessionTaskFailed
    case urlRequestValidationFailed
    case unknown
  }
}
@_hasMissingDesignatedInitializers @propertyWrapper public class Atomic<T> {
  public var projectedValue: Core.Atomic<T> {
    get
  }
  public var wrappedValue: T {
    get
    set
  }
  @objc deinit
}
public struct StorageError : Swift.Error {
  public let column: Swift.Int
  public let line: Swift.Int
  public let kind: Core.StorageError.ErrorKind
  public let underlyingError: (any Swift.Error)?
  public enum ErrorKind {
    case clearFailed
    case deleteFailed
    case readValueFailed
    case writeFailed
    case unknown
    public static func == (a: Core.StorageError.ErrorKind, b: Core.StorageError.ErrorKind) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public init(kind: Core.StorageError.ErrorKind, underlyingError: (any Swift.Error)? = nil, column: Swift.Int = #column, line: Swift.Int = #line)
}
public struct KeychainStorage : Core.Storage {
  public init()
  public init(accessGroup: Swift.String)
  public init(url: Swift.String)
  public func clear() throws
  public func delete(key: Swift.String) throws
  public func readValue<T>(_ type: T.Type, forKey key: Swift.String) throws -> T? where T : Swift.Decodable
  public func write<T>(_ value: T, forKey key: Swift.String) throws where T : Swift.Encodable
}
public struct CoreError : Foundation.LocalizedError {
  public let column: Swift.Int
  public let line: Swift.Int
  public let kind: Core.CoreError.ErrorKind
  public let underlyingError: (any Swift.Error)?
  public var errorDescription: Swift.String? {
    get
  }
  public enum ErrorKind {
    case apiRequestFailed
    case authenticatedClientFailed
    case authenticateFailed
    case deviceAutheticationFailed
    case initializationFailed
    case unknown
    public static func == (a: Core.CoreError.ErrorKind, b: Core.CoreError.ErrorKind) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public init(kind: Core.CoreError.ErrorKind, underlyingError: (any Swift.Error)? = nil, column: Swift.Int = #column, line: Swift.Int = #line)
}
public protocol Storage {
  func clear() throws
  func delete(key: Swift.String) throws
  func readValue<T>(_ type: T.Type, forKey key: Swift.String) throws -> T? where T : Swift.Decodable
  func write<T>(_ value: T, forKey key: Swift.String) throws where T : Swift.Encodable
}
infix operator ++ : DefaultPrecedence
extension Core.ParameterEncoder : Swift.Equatable {}
extension Core.ParameterEncoder : Swift.Hashable {}
extension Core.ParameterEncoding : Swift.Equatable {}
extension Core.ParameterEncoding : Swift.Hashable {}
extension Core.RetryPolicy : Swift.Equatable {}
extension Core.RetryPolicy : Swift.Hashable {}
extension Core.Request.State : Swift.Equatable {}
extension Core.Request.State : Swift.Hashable {}
extension Core.StorageError.ErrorKind : Swift.Equatable {}
extension Core.StorageError.ErrorKind : Swift.Hashable {}
extension Core.CoreError.ErrorKind : Swift.Equatable {}
extension Core.CoreError.ErrorKind : Swift.Hashable {}
